## OOP/AOP

### OOP

?	是一种面向对象的编程思想，它里面有一个理念叫做“万事万物皆对象”，生活中的一切事物其实都可以抽象为对象，这个对象它来源于class，面向对象中中有三大特性，分别是封装，继承和多态，那么封装是什么呢，封装就是将对象的属性和行为封装到类中，然后也可以限定访问权限，python中的权限限定使用的是一个约定俗成的限制方法，通过特殊的手段还是可以访问的，然后是继承，类是可以被继承的，如果一个类继承自某个类，那么那就可以使用那个类中的属性和方法，python中的继承做的很好，python它支持多继承，也是因为python它支持多继承，所以就出现了继承顺序的问题，也就是MRO问题，问了解决这个问题python它经历了三个阶段，在经典类时代使用的是深度优先算法，后来到新式类时代，新式类刚开始使用的是广度优先算法，到后来改为了C3算法，在接下来就是多态，什么是多态呢，多态就是事物的多种形态，比如说猫和动物的例子，那么面向对象它有什么优点呢？它可以简化编程模型，易于维护和扩展，它的缺点是与面向过程编程比较，效率比较低，在现在的开发中，一般使用的都是面向对象编程，这些就是我所理解的面向对象

### AOP

?	是一种面向切面的编程思想，它的核心思想是解耦和，对业务逻辑的各个部分进行隔离，从而使使业务逻辑的各个部分之间的耦合度降低，它的优点是可以动态的介入到业务逻辑代码中，为其增加额外功能，在某些时候性能略低，一般可以用来做打印日志，异常处理，性能统计等	

## socket

?	一切皆socket。为什么这么说，因为TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System的TLI（已被淘汰），来实现网络进程间的通信，然而就目前而言，几乎所有的应用程序都是采用了socket，而现在又是网络时代，网络中进程通信是无处不在，所以可以看做是一切皆socket。

socket起源于Unix然而Unix/Linux基本哲学之一就是“万物皆文件”，都可以使用open->read ->close模式来进行操作，而我的理解就是Socket就是该模式的一个实现（I/O）

socket又称之为“套接字”，是系统提供的用于网络通信的分发，但它的实质并不是一种协议，没有人规定计算机应该怎么传递消息，只是给程序猿提供了一个发送消息的接口，程序猿使用这个接口提供的方法，发送与接收消息。同时它描述了一个ip、端口对，简化了程序员的操作

在使用socket编程时，我们都知道在网络通信以前要先建立连接，而连接的建立是通过对socket的一些操作来完成的，而连接过程大致可分为以下几步：

?	建立socket套接字――使用socket建立套接字的时候，我们实际上是建立了一个数据结构，而这个数据结构最主要的信息是指定了连接的种类和使用的协议

?	给套接字赋予地址，而这个地址不是通常的网络地址的概念。――依照建立套接字的目的不同，赋予套接字地址的方式有两种：服务器端使用bind，客户端使用connetc

?	建立socket连接――对于准备建立一个连接，服务器端要两个步骤：bind, listen；客户端一个步骤：connct。如果服务器端accept一个connect，而客户端得到了这个accept的确认，那么一个连接就建立了。

socket的优点：

?	1.传输数据为字节级，传输数据可自定义，数据量小。相应的移动端开发，手机费用低

   	2.传输数据时间短，性能高

   	3.适合C/S之间信息实时交互

socket的缺点：

 ?	1.需要对传输的数据进行解析，转化为应用级的数据

?	2.对开发人员的开发水平要求高

?    	3.相对于Http协议传输，增加了开发量

socket同时适用于网络游戏、银行交互、支付等服务

## HTTP、TCP、UDP网络协议

### HTTP:

?	HTTP称为 超文本传输协议 是一种基于应用层的通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器,所有的[WWW](https://baike.baidu.com/item/WWW)文件都必须遵守这个标准. 目前我们使用的是HTTP/1.1 版本.HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正

### TCP:

?	TCP协议是面向连接的通信协议,追求安全、稳定或想控制流量的的时候可以使用TCP协议.在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”.

?	三次握手：第一次握手，客户端向服务器端发出连接请求，等待服务器确认，第二次握手，服务器端向客户端回送响应确认，通知客户端收到了连接请求，第三次握手，客户端再次向服务器端发送确认信息，确认连接。

?	四次挥手：第一次挥手: 客户端请求断开连接,等待服务器端确认(FIN)；第二次挥手: 服务端向客户端响应一个确认(ACK)；第三次挥手: 服务端向客户端发送断开连接,等待客户端确认,(FIN)；第四次挥手: 客户端响应给服务端确认(ACK）

### UDP：

?	UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。

?	由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。

?	但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议

## Python中的多线程、多进程、协程

进程，线程，协程其实都是实现多任务实现的方式，多任务实现主要有多进程，多线程，多进程 + 多线程，多进程 + 多协程，他们之间的调度过程叫做上下文切换，进程和线程之间是按照时间片进行切换的，如果在执行切换的时候遇到I/O耗时事件，那么执行耗时任务的那个分支就一直处于等待的过程，对CPU的利用就几乎为0，这样的切换方式显然是非常低效的，如果我们能将执行I/O操作的各分支的时间片抽离出来用到，用到没有I/O操作的分支上，当执行I/O耗时操作的分支耗时任务结束后，再让它执行CPU的调度，这样的方式显然是非常高效的，这样就会出现一个问题就是我们如何知道这个耗时任务已经结束了，有一个方法就是单独有一个进程/线程去去轮询这些耗时任务，这个就是多路复用的思想，但是这样的效果显然也不是很好，更好的办法是让这些耗时任务在执行结束后能够触发一个事件，来告诉我们它已经执行结束了，这个事件就叫做事件驱动，其中协程就实现了这一点，协程可以使用yield将当前的状态抛出，来形成一个事件驱动，然后我们再去轮询这些已经执行结束了的耗时任务，将他们的结果进行返回，这样的话显然是非常高效的一种方式

|      | 资源消耗 | 通信           | 调度方式      |
| ---- | ---- | ------------ | --------- |
| 进程   | 很大   | 不方便，需要使用消息队列 | 时间片切换     |
| 线程   | 小    | 非常方便         | 时间片切换     |
| 协程   | 非常小  | 非常方便         | I/O事件进行切换 |

## Django、Flask框架

### Django框架

Django是一个基于python的重量级Web框架，为什么说它重呢，是因为Django替开发者想了太多的事情，它默认集成了很多的模块供开发者使用，
Django的优点是它是开源的，有完善的文档支持，内部为开发者实现了很多的功能，并且有自己的后台管理系统，
它的缺点是耦合度偏高，定制起来比较麻烦，Django它适用于快速高效的项目开发。
在开发中，有一种MVC的软件架构思想，它的核心是解耦和，意在将数据展示，业务处理，数据操作进行解耦和，就耦合就是分离的意思，
	它的M指的的是Model，对接的是数据，封装了数据相关操作，V指View，对接的是用户，负责将数据展示给用户看，C指的是Controller，对接的是业务逻辑处理，同时协调Model和View，是一个协调者，
	MVC设计模式的优点是将数据展示，业务处理和数据操作进行了解耦和，提高了代码的可维护性和扩展性，
	缺点是，他需要对各个功能模块进行拆分，性能可能会有所降低，一般适用于较大项目的开发中，
	这种架构思想在Django中也有体现，Django中使用的是MTV设计模式，它是MVC的一个衍生版，本质其实还是MVC，他的M对应MVC中的M，T对应MVC中的V，V对应MVC中的C，所以在Django中同样也实现了代码的解耦和，
	我再来说下Django中的MTV，M，Model也就是模型，
这里面使用了ORM技术，ORM它是一种程序技术，叫做对象关系映射，他的核心思想也是解耦和，它解的是数据操作和数据库的耦和，在ORM技术中，当数据库需要更换时，只需要更改一下相关的配置就可以了，而且不会影响其他的功能，如果使用的是原生的SQL语句，那么显然是保证不了这一点，ORM它的优点是可以以快速的实现开发，可以在不懂SQL语句的情况下完成开发，还可以避免SQL注入，相对比较安全，它的缺点是性能略低于原生的SQL语句，而且对于复杂的SQL语句没有提供实现，在中小型的项目开发中，一般使用的都是ORM技术，可以方便高效的完成项目的开发，在Model模型中还提供了模型迁移系统和字段映射，可以将模型及模型字段映射到数据库中，接下来是MTV中的T，Django提供了专门的模板语法将数据渲染到前端页面上，然后就是Vews视图函数，
它包含FBV和CBV，FBV是function base view基于函数的视图函数，CBV是class base view基于类的视图函数，用户的请求根据url路由器分发到对应的视图函数中，视图函数中又有一个双R的概念，也就是Request(请求)和Response(响应)，这些就是Django中的MTV,此外Django中还提供了一个中间件机制Middware，中间件是Django内置的一个底层插件，它是面向切面编程的一个体现，中间件有五个切点，分别是**process_request(self,request);process_view(self,request,callback,callback_args,callback_kwargs);process_template_response(self,request,response);process_exception(self,request,exception);process_response(self, request, response)**，它 的优点是可以动态的介入到请求中，实现代码复用，在不修改源代码的前提下，添加新的逻辑，使用的场景有统计功能，权重控制实现（黑/白名单），基本反爬实现等

### Flask框架

flask是一个基于Python的Web微框架，只保留了最核心的模块，其余的都交给开发者自己扩展，是一个非常灵活的Web框架，

flask的优点是它是一个轻量级的框架，更加的灵活，而且flask是开源的，有完善的技术文档支持，方便学习和使用

缺点是需要依赖各种三方库，三方库需要自己下载，利用flask可以快速完成小型项目的开发，对于大型项目的开发需要自己对项目架构进行设计。

Flask中使用的是MVC，或者叫做MVT设计模式，本质还是MVC核心组成有路由器（flask中中路由是由装饰器实现的），视图函数，模型（需要使用三方扩展库），模板（使用的是Jinja2模板），
比较常用的三方扩展有flask-caching缓存，flask-mail发邮件，flask-script接受命令行参数，flask-sqlalchemyORM技术，flask-migrate迁移系统，flask-bootstrap继承自Bootstrap框架，flask-restapi接口编写等，flask依靠这些强大的三方扩展可以实现快速高效的项目开发

## MVC/MTV,生产者，消费者，观察者设计模式

### MVC：

MVC是一个设计模式，核心思想是解耦和（分离），意在将数据展示，业务处理，数据操作进行解耦和。它强制性的使[应用程序](http://baike.baidu.com/view/330120.htm)的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型Model、视图View、控制器Controller。它们各自处理自己的任务。MVC模式的目的是实现一种动态的程序的设计，使后续对程序的修改和扩展简化。并且使程序某一部分的重复利用成为可能。MVC的优点是开发人员可以只关注这个结构中的其中某一层，可以很容易的用新的实现来替换原有层次的实现，可以降低层与层之间的依赖，有利于标准化，利于各层逻辑的复用。它的缺点是增加了系统结构和实现的复杂性，视图与控制器之间过于紧密的连接，视图对模型数据的低效率访问

Model――对接数据，封装数据相关操作。

View――对接用户，将数据呈现给用户。

Controller――对接业务，封装业务逻辑处理，是Model和View的协调者。

### MTV:

Django中的MTV模式本质上是和MVC是一样的，也是为了各组件间保持松耦合关系。

Model模型负责业务对象和数据库的关系映射（ORM）；模板Template负责如何把页面展示给用户（HTML）；视图View负责业务逻辑，并在适当的时候调用Model和Template。然而除此之外，MTV还需要一个URL分发器，它的作用是将一个个URL的页面请求分发非不同的View处理，View再调用相应的Model和Template・

### 生产者消费者：

生产者与消费者模型的矛盾在于数据供需的不平衡。在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。这个阻塞队列就是用来给生产者和消费者解耦的。纵观大多数设计模式，都会找一个第三者出来进行解耦。

### 观察者：

?	观察者模式，又被称为模型-视图模式。定义了对象之间的一种一对多的依赖关系，从而使得当被观察对象状态发生变化时，自动通知其依赖对象，并且依赖对象自动更新。它可以解决被观察对象的状态改变如何主动通知其依赖的对象，同时需要考虑到低耦合和易用性，保证高度协作。通过面向对象技术弱化这种依赖关系。抽象类中设置一个ArrayList存放所有的观察者。优点是目标对象和观察者对象是抽象耦合的，并且建立了一套触发机制。但是他也有相应的缺点，观察者模式只是主动通知了目标对象发生了变化，没有相应的机制使得观察者知道所观察的目标对象如何发生变化的。观察者和观察目标之间可能存在循环依赖，观察者模式中目标对象可能触发两者之间的循环调用，从而系统存在崩溃风险。如果目标对象存在多个直接或间接的观察者对象，主动通知所有的观察者会消耗大量的资源，花费大量时间。我们可以这么理解――在众多游戏中，主角行走过程中，地图中心摄像头总是跟随主角调整视角和位置，使得主角总是处于场景的中心。主角进行行走或战斗操作时，主角的仆从根据主角的操作进行相应的跟随或战斗行为。

## Celery并行分布式框架

Celery是一个简单灵活的分布式系统，主要处理异步任务和定时任务，Celery有四个模块，分别是Task任务队列，中间件，Workor，Bankend（存储，可要可不要），通过中间件把任务队列中的任务交给Workor处理，并进行监听，主要用于Web中遇到的I/O耗时任务处理

## RESTful及DRF

### RESTful

是一种软件架构风格，提供的是一组约束条件，这种设计风格的优点是可以实现前后端分离实现，对接不同的端，像安卓，ios，pc端等，解决了前后端相互等待的问题，前后端可以同时进行开发，它的缺点是对前后端的技术要求变高，RESTful一般在前后端分离的项目中使用，实现多端适用+

### DRF

DRF是一个基于Django的快速实现API接口开发的重量级框架，它的核心思想是实现前后端的分离，其中的核心是实现了RESTAPI里面的序列化以及视图处理，它这里面就包含了序列化器及视图函数，视图函数里面又包含了认证，权限，节流器，版本，我们这个优点是能够快速实现API开发并且能够将我们的代码进行拆分，当然它也有缺点，它的缺点是定制起来比较麻烦，内置原理理解起来比较困难。里面的序列化器是第一个核心-+，序列化器的功能是实现序列化与反序列化，也就是对象和json数据的一个互转关系，它能为我们提供一些字段验证，其实就是将每一个字段进行逐个转换，然后序列化又分为几种，分别为原生序列化，模型序列化，超链接的序列化，在接下来就是视图函数，视图函数又包含CBV和FBV，也就是function base view和class base view，CBV的就是继承自APIView，APIView里面就有as_view和dispatch，这里面会先执行Request重构，然后进行认证，权限，节流，然后这个认证，它会遍历认证器，只要有一个认证通过，然后是权限，挨个执行权限判定，必须所有权限都满足，才能算是拥有权限，否则权限认证失败，接下来是节流器，获取节流器，通过allow_request()方法进行判断，若允许则通过，若不允许则直接抛异常，接下来就是路由分发，dispatch会将请求分发到对应的视图函数中，在视图函数进行对应的逻辑处理，最后返回Response

## logging模块

logging模块是Python内置的标准模块，主要用于输出运行日志，通过对log的分析可以了解项目的运行情况，log可以用来对问题进行追踪，对状态进行监控等，log模块有四大组件，分别为Loggers，Handlers（处理者）， Filters（过滤器），Formatters（格式化）log的等级分为五种，又高到低分别为DEBUG，INFO，WARNING，ERROR，CRITICAL

## 数据库常用优化

### 1.选取最适用的字段属性

?	数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。另外还有一种提高效率的办法是在允许的情况下，尽量把字段设置为not null，这样数据库查询的时候不需要去比较null值

### 2.使用连接（JOIN）来代替子查询(Sub-Queries)

?	使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易，但是使用链接（JOIN）来完成查询的工作速度会快很多

#### 3.使用联合(UNION)来代替手动创建的临时表

?	MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要相同。

### 4.少使用外键

?	设计表时，尽量少的使用外键，外键约束会影响插入和删除性能。

### 5.使用索引

?	索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度。尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。

### 6.优化的查询语句

?	绝大多数情况下，使用索引可以提高查询的速度，但如果SQL语句使用不恰当的话，索引将无法发挥它应有的作用

### 7.使用缓存

?	使用缓存，减少对数据库的访问。

## ORM

?	在说ORM之前，我们先来了解以下概念。什么是持久化（Persistence）？，就是把数据保存到可以永久保存的存储设备中，它主要是将内存中的数据存储在关系型的数据库中。什么是持久层（Persistence Layer）？，即专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据的使用者与数据实体相关联。那么接下来我们说一下什么是ORM，即Object-Relational Mapping，

它的作用是在关系型数据库和对象之间作一个映射，这样我们就不用去操作复杂的SQL语句，而是像操作对象一样操作就可以了

那么为什么会出现ORM的思想，那么先从项目中数据流存储形式这个角度说起。简单拿MVC这种分层模式来说. Model作为数据承载实体. 在用户界面层和业务逻辑层之间数据实现面向对象OO形式传递. 当我们需要通过Control层分发请求把数据持久化时我们会发现.  内存中的面向对象的OO如何持久化成关系型数据中存储一条实际数据记录呢？面向对象是从软件工程基本原则(如耦合、聚合、封装)的基础上发展起来的，而关系数据库则是从数学理论发展而来的.? 两者之间是不匹配的.而ORM作为项目中间件形式实现数据在不同场景下数据关系映射. 对象关系映射（Object Relational Mapping，简称ORM）是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术.ORM就是这样而来的.那么ORM的优势有隐藏数据访问细节，它使得我们的通用数据库交互变得简单易行，不用去考虑SQL语句；第二ORM使我们构造固化数据结构变得简单易行。在ORM年表的史前时代，我们需要将我们的对象模型转化为一条一条的SQL语句。现在，基本上所有的ORM框架都提供了通过对象模型构造关系数据库结构的功能。但是ORM也有几个缺点，首先是无可避免的性能的牺牲，这也是早期所有不喜欢ORM的人的共同点吧，而现在ORM也在使用各种方法来解决比如LazyLoad、Cache；第二面向对象的查询语言，作为一种数据库与对象之间的过渡,虽然隐藏了数据层面的业务抽象,但并不能完全的屏蔽掉数据库层的设计，这无疑增加学习成本。其三对于复杂查询，ORM仍然力不从心。虽然可以实现，但是不值的。相比较而言视图可以解决大部分的复杂查询问题

## Redis非关系型数据库及缓存技术

?	Redis是一个基于内存的高性能key-value数据库，很像Mecached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 mMmcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能，比方说用

1、他的List来做FIFO双向链表，实现一个轻量级的高性能消息队列服务，

2、用他的Set可以做高性能的tag系统等等。

3、另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一个功能加强版的Memcached来用。

Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。

Redis支持的数据类型有字符串、列表、集合、有序集合、哈希。Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以Redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响Redis的性能。在内存越来越便宜的今天，Redis将会越来越受欢迎。

### Memcacahe与redis区别有哪些

?	存储方式，Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部份存在硬盘上，这样能保证数据的持久性；数据+类型，Memcache对数据类型支持相对简单。Redis有复杂的数据类型；使用底层模型不同，它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；Value大小，Redis最大可以达到1GB，而Memcache只有1MB

## MYSQL

?	MYSQL是一种关系型数据库，它强调的是表关系，它里面有一个库（相当于一个Excel）和表（相当于一个Excel的sheet）的概念，行就是一个数据，列就是一个属性，比较常见的关系型数据库还有SQLite，Oracle，这里面就有涉及到一个SQL分类，DDL（数据库定义操作），DML（数据库管理操作）和DQL（数据库查询语句），DML就是CRUD操作

## MongodB

?	MongodB是一个非关系型数据库，也有个说法叫做最像关系型数据库的数据库，它的存储结构是按照文档进行存储，使用的BSON（类似于JSON），优点是弱化了关系，缺点是数据操作命令过于复杂，不便于记忆，一般会在爬虫中使用

## 网页抓取的思想和Scrapy框架

### 网页抓取的思想

### Scrapy框架

?	在python爬虫中：requests  +  selenium  可以解决目前90%的爬虫需求，难道scrapy 是解决剩下的10%的吗？显然不是。scrapy 是一个为了爬取网站数据，提取结构性数据而编写的应用框架，我们只需要实现少量代码，就能够快速的抓取到数据内容。Scrapy 使用了 Twisted['tw?st?d](其主要对手是Tornado)异步网络框架来处理网络通讯，可以加快我们的下载速度，不用自己去实现异步框架，并且包含了各种中间件接口，可以灵活的完成各种需求。scrapy五大基本组成有调度器(Scheduler)、下载器(Downloader)、爬虫（Spider）和实体管道(Item Pipeline)、Scrapy引擎(Scrapy Engine)，scrapy请求发出去的整个流程大致如下：首先爬虫将需要发送请求的url（requests）经引擎交给调度器；排序处理后，经ScrapyEngine，DownloaderMiddlewares(有User_Agent, Proxy代理)交给Downloader;Downloader向互联网发送请求，并接收下载响应.将响应经ScrapyEngine，可选交给Spiders;Spiders处理response，提取数据并将数据经ScrapyEngine交给ItemPipeline保存;提取url重新经ScrapyEngine交给Scheduler进行下一个循环。直到无Url请求程序停止结束。

### 异步和非阻塞

?	异步：调用在发出之后，这个调用就直接返回，不管有无结果

?	非阻塞：+关注的是程序在等待调用结果（消息，返回值）时的状态，指在不能立即得到结果之前，该调用不会阻塞当前进程