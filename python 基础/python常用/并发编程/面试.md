**协程的优缺点：**

```
参考：https://www.cnblogs.com/haixiaozh/p/13497108.html
协程的优点：
（1）无需线程上下文切换的开销，协程避免了无意义的调度，由此可以提高性能（但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力）
（2）无需原子操作锁定及同步的开销
（3）方便切换控制流，简化编程模型
（4）高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。
 (5) 协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
 (6)不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

协程的缺点：
（1）无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。
（2）进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序

因为协程是一个线程执行，那怎么利用多核CPU呢？
最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能
Python对协程的支持是通过generator实现的。
在generator中，我们不但可以通过for循环来迭代，还可以不断调用next()函数获取由yield语句返回的下一个值。
但是Python的yield不但可以返回一个值，它还可以接收调用者发出的参数。
```

**全局解释器锁（GIL）**

```
Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。
对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。
```

**什么时候用多线程，什么时候用多进程？**

```
多线程：io操作密集的时候
多进程：cpu耗用过多的时候
```

**进程和线程的区别**

```
1.进程是资源分配的最小单位，线程是程序执行的最小单位。
2.进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
3.线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，
进程:通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。
4.程序健壮
多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间
```

**python 中异步的场景**

```
异步的使用场景:
1、 不涉及共享资源，获对共享资源只读，即非互斥操作
2、 没有时序上的严格关系
3、 不需要原子操作，或可以通过其他方式控制原子性
4、 常用于IO操作等耗时操作，因为比较影响客户体验和使用性能
5、 不影响主线程逻辑
```

**解释一下什么是锁，有几种锁?**

```
锁(Lock)是python提供的对线程控制的对象。有互斥锁，可重入锁，死锁。
```

**什么是死锁？**

```
若干子线程在系统资源竞争时，都在等待对方对某部分资源解除占用状态，结果是谁也不愿先解锁，互相干等着，程序无法执行下去，这就是死锁。
GIL锁 全局解释器锁
作用： 限制多线程同时执行，保证同一时间只有一个线程执行，所以cython里的多线程其实是伪多线程！
所以python里常常使用协程技术来代替多线程，协程是一种更轻量级的线程。
进程和线程的切换时由系统决定，而协程由我们程序员自己决定，而模块gevent下切换是遇到了耗时操作时才会切换
三者的关系：进程里有线程，线程里有协程。
```

**说一下同步、异步、阻塞、非阻塞?**

```
同步： 多个任务之间有先后顺序执行，一个执行完下个才能执行。
异步： 多个任务之间没有先后顺序，可以同时执行，有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调！
阻塞： 如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。
非阻塞： 如果不会卡住，可以继续执行，就是说非阻塞的。
同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。
```

**IO密集型和CPU密集型的区别？**

```
IO密集型： 系统运行，大部分的状况是CPU在等 I/O（硬盘/内存）的读/写,多进程
CPU密集型： 大部分时间用来做计算，逻辑判断等CPU动作的程序称之CPU密集型，多线程
```

**并行和并发**

```
并行(进程)同一时刻多个任务同时在运行（multiprocessing）
并发(线程)不会在同一时刻同时运行，存在交替执行的情况（threading）
并行(进程)程序需要执行较多的读写,并发(线程)请求和回复任务的需要大量的IO操作
IO密集型操作使用并发更好,CPU运算量大的程序，使用并行会更好
```

**什么是僵尸进程，什么是孤儿进程？**

```
孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init 进程（进程号为1）所收养，并由init 进程对他们完成状态收集工作。
僵尸进程： 进程使用fork 创建子进程，如果子进程退出，而父进程并没有调用wait 获waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。
避免僵尸进程的方法：
1.fork 两次用孙子进程去完成子进程的任务
2.用wait()函数使父进程阻塞
3.使用信号量，在signal handler 中调用waitpid,这样父进程不用阻塞
```

**多线程交互访问数据，如果访问到了就不访问了？**

```
怎么避免重读？
创建一个已访问数据列表，用于存储已经访问过的数据，并加上互斥锁，在多线程访问数据的时候先查看数据是否在已访问的列表中，若已存在就直接跳过。
```

**join()**

```
join（线程同步) join 所完成的工作就是线程同步，即主线程任务结束以后，进入堵塞状态，一直等待所有的子线程结束以后，主线程再终止。

当设置守护线程时，含义是主线程对于子线程等待timeout的时间将会杀死该子线程，最后退出程序，所以说，如果有10个子线程，全部的等待时间就是每个timeout的累加和，简单的来说，就是给每个子线程一个timeou的时间，让他去执行，时间一到，不管任务有没有完成，直接杀死。

没有设置守护线程时，主线程将会等待timeout的累加和这样的一段时间，时间一到，主线程结束，但是并没有杀死子线程，子线程依然可以继续执行，直到子线程全部结束，程序退出。
import threading
import time

def thread():
    time.sleep(2)
    print('---子线程结束---')

def main():
    t1 = threading.Thread(target=thread)
    t1.setDaemon(True)
    t1.start()
    t1.join(timeout=1)#1 线程同步，主线程堵塞1s 然后主线程结束，子线程继续执行
                        #2 如果不设置timeout参数就等子线程结束主线程再结束
                        #3 如果设置了setDaemon=True和timeout=1主线程等待1s后会强制杀死子线程，然后主线程结束
    print('---主线程结束---')

if __name__=='__main___':
    main()
```

**setDaemon（True)**

```
setDaemon（True) 当我们使用setDaemon(True)时，这是子线程为守护线程，主线程一旦执行结束，则全部子线程被强制终止
import threading
import time
def thread():
    time.sleep(2)
    print(’---子线程结束---')
def main():
    t1 = threading.Thread(target=thread)
    t1.setDaemon(True)#设置子线程守护主线程
    t1.start()
    print('---主线程结束---')

if __name__ =='__main__':
    main()
```

**python 的线程同步？**

```
setDaemon(False) 当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行的最小单位，当设置多线程时，主线程会创建多个子线程，在Python中，默认情况下就是setDaemon(False),主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。

例子

import threading 
import time

def thread():
    time.sleep(2)
    print('---子线程结束---')

def main():
    t1 = threading.Thread(target=thread)
    t1.start()
    print('---主线程--结束')

if __name__ =='__main__':
    main()
#执行结果
---主线程--结束
---子线程结束---
```

