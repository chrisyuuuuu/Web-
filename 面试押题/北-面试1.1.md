**python 数据结构的基本特点**

- 列表

  - 列表中的每个元素都可变的，意味着可以对每个元素进行修改和删除；
  - 列表是有序的，每个元素的位置是确定的，可以用索引去访问每个元素；
  - 列表中的元素可以是Python中的任何对象，这意味着元素可以是字符串、整数、元组、也可以是list等Python中的对象

- 元组

  - 元组Tuple，用法与List类似，但Tuple一经初始化，就不能修改，没有List中的append(), insert(), pop()等修改的方法，只能对元素进行查询

- 字典

  - 字典中的数据必须以键值对的形式出现
  - 键不可重复，值可重复
  - 字典中键(key)是不可变的，何为不可变对象，不能进行修改；而值(value)是可以修改的，可以是任何对象：

- 集合

  - 集合中每个元素都是无序的、不重复的任意对象
  - 集合内数据无序，即无法使用索引和分片
  - 集合内部数据元素具有唯一性，可以用来排除重复数据
  - 可以通过集合去判断数据的从属关系。集合可做集合运算，可添加和删除元素

- 迭代器和生成器的区别

  - 共同点
    - 生成器是一种特殊的迭代器
  - 不同点
    - 语法
      - 生成器是通过函数的形式中调用 yield 或（）的形式创建的
      - 迭代器可以通过 iter（） 内置函数创建
    - 用法
      - 
        生成器在调用next（）函数或for循环中，所有过程被执行，且返回值，生成器是只能遍历一次的。
      - 迭代器在调用next（）函数或for循环中，所有值被返回，没有其他过程或说动作

- python垃圾回收机制

   - 垃圾回收

   - python采用的是**引用计数**机制为主，**标记-清除**和**分代收集**两种机制为辅的策略。

      -	当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。
      -	当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。
        	（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。

  -	内存池机制

    -	Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。

      1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。

      2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。

      3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。

  -	对象的引用计数机制

    -	Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。

- 表锁和行锁的区别及使用场景

  - 表锁
    - 不会出现死锁，发生锁冲突几率高，并发低
    - 表级锁有两种模式：表共享读锁，表独占写锁
    - 读锁会阻塞写，写锁会阻塞读和写
    - MyISAM不适合做写为主表的引擎，因为写锁后，其它线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞
  - 行锁
    - **会出现死锁，发生锁冲突几率低，并发高**
    - 在MySQL的InnoDB引擎支持行锁
    - MySQL的行锁是通过索引加载的

- 斐波那契数列

  - ```
    def feibo(n):
        if n <=2:
            sums = 1
            return  sums
        else:
            return feibo(n-1)+feibo(n-2)
    print(feibo(10))
    # 3 f2+f1
    # 4 f3+f2
    # 5 f4+f3
    ```

- __init__和___new____的区别

  - ```
    
    __new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例对象，是个静态方法。
    __init__是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候。是一个实例方法。
    
    也就是： __new__先被调用，__init__后被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。
    
    
    ```

- 数据库备份的方法

  - 命令
  - navicate数据库图形化工具进行备份

- 装饰器的两种常用方式

  - https://www.cnblogs.com/syw20170419/p/11058203.html

- 为什么多线程比较慢

  - 当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换
  - 执行CPU时间片      保存状态     下次切换    加载状态
  - 多线程的总体执行时间和单线程是一样的，但是多线程中**单个线程**的执行时间是单线程的多倍。
  - 首先分配cpu资源的单位是进程。一个进程所获得到的cpu资源是一定的。程序在执行的过程中消耗的是cpu，比如一个单核cpu，多个线程同时执行工作时，需要不断切换执行(上下文切换)，单个线程时间耗费更多了，而单线程只是一个线程跑
  -  原因就在于 GIL ，在 Cpython 解释器（Python语言的主流解释器）中，有一把全局解释锁（Global Interpreter Lock），在解释器解释执行 Python 代码时，先要得到这把锁，意味着，任何时候只可能有一个线程在执行代码，其它线程要想获得 CPU 执行代码指令，就必须先获得这把锁，如果锁被其它线程占用了，那么该线程就只能等待，直到占有该锁的线程释放锁才有执行代码指令的可能。
  - 这也就是为什么两个线程一起执行反而更加慢的原因，因为同一时刻，只有一个线程在运行，其它线程只能等待，即使是多核CPU，也没办法让多个线程「并行」地同时执行代码，只能是交替执行，因为多线程涉及到上下文切换、锁机制处理（获取锁，释放锁等），所以，多线程执行不快反慢。

- MySQL中的锁（https://www.cnblogs.com/chenqionghe/p/4845693.html）

  - **锁是计算机协调多个进程或纯线程并发访问某一资源的机制。**

  - MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。

    MySQL大致可归纳为以下3种锁：

    - 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
      - 表共享锁（Table Read Lock）
      - 表独占写锁（Table Write Lock）
      - MyISAM表的读操作和写操作之间，以及写操作之间是串行的。
    - 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
      - 共享锁（s）
      - 排他锁（Ｘ）
      - 意向共享锁（IS）
      - 意向排他锁（IX
    - 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

  - 什么时候用表锁？

    - 事务需要更新大部分或全部数据，表又比较大（行锁不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突）
    - 事务涉及多个表，比较复杂，避免引起死锁，造成大量事务回滚

  - 死锁

    - ＭyISAM表锁是deadlock free的，这是因为ＭyISAM总是一次性获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁
    - 在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了InnoDB发生死锁是可能的。
    - 解决死锁
      - 在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低死锁的可能。
      - 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁，更新时再申请排他锁，甚至死锁。
      - 当隔离级别为READ COMMITED时，如果两个线程都先执行SELECT...FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第１个线程提交后，第２个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第３个线程又来申请排他锁，也会出现死锁。对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁
      - 在REPEATEABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT...ROR UPDATE加排他锁，在没有符合该记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可以避免问题。