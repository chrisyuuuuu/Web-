> **表结构**

```
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Author(models.Model):
    name = models.CharField(max_length=50)
    email = models.EmailField()

    def __str__(self):              # __unicode__ on Python 2
        return self.name

class Entry(models.Model):
    blog = models.ForeignKey(Blog)
    headline = models.CharField(max_length=255)
    body_text = models.TextField()
    pub_date = models.DateField()
    mod_date = models.DateField()
    authors = models.ManyToManyField(Author)
    n_comments = models.IntegerField()
    n_pingbacks = models.IntegerField()
    rating = models.IntegerField()

    def __str__(self):              # __unicode__ on Python 2
        return self.headline
# 生成表
operate_blog
operate_author
operate_entry
operate_entry_authors
```

> **增**

- **不包含关联字段**

  ```
  #方式一
  b1 = Blog(name="python项目实战",tagline="开发")
  b1.save()
  
  # Blog.objects.create(name="python基础",tagline="了解语言")
  ```

- **包含关联字段**

  ```
  # 一对多
  e1=Entry(blog=b1,headline="天天书店",body_text="共有12章",pub_date=("2091-11-2"),mod_date=("1212-2-1"),n_pingbacks=1233,n_comments=123,rating=1
  10)
  e1.save()
  
  # 一对多
  e1=Entry.objects.get(pk=4)
  a1=Author.objects.get(pk=1)
  a2=Author.objects.get(pk=2)
  
  e1.authors.add(a1,a2)
  ```

> 删

```
# 1.这是一种保护机制，是为了避免意外地调用 Entry.objects.delete() 方法导致 所有的 记录被误删除
# 2.这是一种保护机制，是为了避免意外地调用 Entry.objects.delete() 方法导致 所有的 记录被误删除
```

> 改

```
# 多个对象，更新一个字段，非关系字段和 ForeignKey 外键字段
Entry.objects.filter(pub_date__year=2007).update(headline='Everything is the same')


# 更新关联表不可能

# 更新时，F()不能关联表
Entry.objects.update(headline=F('blog__name'))
```



> **查**

 - **字段筛选条件(field__lookuptype=value)**

   ```
   Entry.objects.filter(pub_date__lte='2006-01-01')
   
   # lookuptype 
   lt, gt, exact,iexact(忽略大小写)
   contains,startswith,endswith
   ```

-	**跨关系查询--针对关联表和被关联表(默认表名-__field__-lookuptype)互逆**

  ```
  # Entry --> Blog
  Entry.objects.filter(blog__name__exact='Beatles Blog')
  
  Blog.objects.filter(entry__headline__contains='Lennon')
  
  # 注意:找不到,不会报错
  ```
  
- **正向关联**

  ```
  # 查
  >>> e = Entry.objects.get(id=2)
  >>> e.blog # Returns the related Blog object.
  
  # 改
  >>> e = Entry.objects.get(id=2)
  >>> e.blog = some_blog
  >>> e.save()
  
  #在一对多关系中，第一次正向获取关联对象时，关联对象会被缓存。其后根据外键访问时这个实例，就会从缓存中获得它。
  >>> e = Entry.objects.get(id=2)
  >>> print e.blog  # Hits the database to retrieve the associated Blog.
  >>> print e.blog  # Doesn't hit the database; uses cached version.
  ```

- **反向关联**

  ```
  # 查
  >>> b = Blog.objects.get(id=1)
  >>> b.entry_set.all() # Returns all Entry objects related to Blog.
  ```

  